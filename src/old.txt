#include <linux/bpf.h>
#include <linux/if_ether.h>
#include <linux/ip.h>
#include <linux/in.h>
#include <bpf/bpf_helpers.h>

#define MAX_RING_BUFFER_ENTRIES 16384

typedef struct {
    __u64 timestamp_ns;
    __u32 pkt_len;
    __u8 pkt_data[];
} packet_event_t;

struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, MAX_RING_BUFFER_ENTRIES);
    __uint(key_size, 0);
    __uint(value_size, 0);
} ring_buffer SEC(".maps");

SEC("xdp")
int xdp_prog(struct xdp_md* ctx) {
    void* data = (void*)(long)ctx->data;
    void* data_end = (void*)(long)ctx->data_end;
    
    struct ethhdr* eth = (struct ethhdr*)data;
    if ((void*)(eth + 1) > data_end) return XDP_PASS;
    if (eth->h_proto != __constant_htons(ETH_P_IP)) return XDP_PASS;

    struct iphdr* ip = (struct iphdr*)(eth + 1);
    if ((void*)(ip + 1) > data_end) return XDP_PASS;
    if (ip->protocol != IPPROTO_TCP || ip->protocol != IPPROTO_UDP) return XDP_PASS;

    __u32 pkt_len = data_end - data;
    if (pkt_len == 0) return XDP_PASS;

    packet_event_t* event = bpf_ringbuf_reserve(&ring_buffer, sizeof(*event) + pkt_len, 0);
    if (!event) return XDP_PASS;

    event->timestamp_ns = bpf_ktime_get_ns();
    event->pkt_len = pkt_len;

    if (bpf_probe_read_kernel(event->pkt_data, pkt_len, data) < 0) {
        bpf_ringbuf_discard(event, 0);
        return XDP_PASS;
    }

    bpf_ringbuf_submit(event, 0);

    return XDP_PASS;
}

/*
    - Test out, will it fail if you try to reference a global
      pointer thats outside the main function?

    - The {type} name[] syntax in a struct says that what follows is an
      array of data. This is called a Flexible Array Member (FMA). It is
      not a stored pointer and is ignored when computing sizeof(struct).
*/